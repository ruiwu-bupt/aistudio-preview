<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Studio对话查看器</title>
    <!-- 引入marked.js用于解析Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            font-size: 14px;
            line-height: 1.5;
            background-color: #ffffff;
            color: #343a40;
        }
        
        .sidebar {
            width: 280px; /* 稍微加宽一点 */
            min-width: 220px; /* 设置最小宽度 */
            max-width: 600px; /* 设置最大宽度 */
            background-color: #f8f9fa; /* 浅灰色背景 */
            padding: 15px;
            border-right: 1px solid #dee2e6; /* 更柔和的边框 */
            box-sizing: border-box;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }
        
        #sidebar-resizer {
            position: absolute;
            top: 0;
            right: -5px; /* 稍微调整位置 */
            width: 10px; /* 加宽可点击区域 */
            height: 100%;
            cursor: col-resize;
            background-color: transparent; 
            z-index: 100; 
        }
        
        #sidebar-resizer:hover {
             background-color: rgba(0, 123, 255, 0.1); 
        }
        
        .main-content {
            flex-grow: 1;
            padding: 15px 20px; /* 调整左右边距 */
            overflow-y: auto;
            box-sizing: border-box;
            background-color: #ffffff;
            display: flex; /* 使用flex布局 */
            flex-direction: column; /* 垂直排列 */
        }
        
        .file-upload {
            margin-bottom: 10px; /* 减小文件上传区域间距 */
        }
        
        .file-upload h2 {
            font-size: 1.1rem; /* 减小标题 */
            margin-bottom: 10px; 
        }
        
        .outline {
            margin-top: 15px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .outline h3 {
            font-size: 1rem; 
            margin: 0 0 5px 0; /* 减小标题底部间距 */
            color: #495057;
            padding-bottom: 5px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .outline-options {
            font-size: 0.75rem;
            color: #6c757d;
            margin-bottom: 8px;
            display: flex;
            gap: 10px;
        }
        
        .outline-options label {
             cursor: pointer;
             display: inline-flex; /* 让input和文字对齐 */
             align-items: center;
             gap: 3px;
        }
        
        .outline-options input[type="radio"] {
             margin: 0;
             width: 12px; /* 调整大小 */
             height: 12px;
        }
        
        .search-box {
            margin-bottom: 10px;
            width: 100%;
        }
        
        .search-input {
            width: 100%;
            padding: 8px 12px; /* 增加内边距 */
            border: 1px solid #ced4da;
            border-radius: 0.25rem; /* 使用rem单位 */
            box-sizing: border-box;
            font-size: 0.9rem;
            transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }
        
        .search-input:focus {
            border-color: #80bdff;
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
        }
        
        #outline-content {
            overflow-y: auto;
            flex-grow: 1;
            /* max-height calculation removed, handled by flexbox */
        }
        
        .outline-item {
            margin-bottom: 2px; /* 减小间距 */
            cursor: pointer;
            color: #007bff; /* 主题蓝色 */
            padding: 6px 8px; /* 调整内边距 */
            border-radius: 0.25rem;
            font-size: 0.85rem;
            transition: background-color 0.15s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .outline-item:hover {
            text-decoration: none; /* 移除下划线 */
            background-color: #e9ecef; /* 柔和的悬停背景 */
            color: #0056b3; /* 深一点的蓝色 */
        }
        
        .outline-item.hidden {
            display: none;
        }
        
        .outline-item.highlight {
             background-color: #cfeffd !important; /* 更明显的高亮 */
             font-weight: bold;
        }
        
        .message {
            max-width: 80%; /* 限制消息最大宽度 */
            margin-bottom: 0.8rem; /* 减小消息间距 */
            padding: 0.6rem 1rem; /* 减小上下内边距 */
            border-radius: 0.5rem; /* 更圆润的边角 */
            border: 1px solid transparent; 
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
            word-wrap: break-word; /* 自动换行 */
            align-self: flex-start; /* 默认靠左 */
        }
        
        .user-message {
            background-color: #007bff; /* 主题蓝色背景 */
            color: white; /* 白色文字 */
            border-left: none; /* 移除左边框 */
            align-self: flex-end; /* 用户消息靠右 */
            border-bottom-right-radius: 0; /* 右下角直角 */
            margin-top: 0.3rem; /* 进一步减小边距 */
            margin-bottom: 0.3rem;
            padding: 0.5rem 1rem; /* 用户消息padding可以更小 */
        }
        
        .model-message {
            background-color: #f1f3f5; /* 浅灰色背景 */
            border-left: 4px solid #ced4da;
            color: #343a40;
            border-bottom-left-radius: 0; /* 左下角直角 */
        }
        
        .message-header {
            font-weight: 600; 
            margin-bottom: 0.5rem; /* 减小头部间距 */
            font-size: 0.8rem; /* 减小头部字体 */
            color: inherit;
            opacity: 0.7;
            text-transform: uppercase; /* 角色大写 */
        }
        
        .user-message .message-header {
            /* 可以选择隐藏用户消息的头部，或改变颜色 */
             display: none; 
            /* color: rgba(255, 255, 255, 0.7); */
        }
        
        #no-file {
            text-align: center;
            color: #6c757d;
            margin-top: 5rem;
            font-size: 1.1rem;
        }
        
        #no-file h2 {
            color: #495057;
            margin-bottom: 0.5rem;
        }
        
        /* Markdown样式优化 */
        .markdown-content h1,
        .markdown-content h2,
        .markdown-content h3 {
            color: #495057;
            margin-top: 1.5em;
            margin-bottom: 0.8em;
            font-weight: 600;
        }
        .markdown-content h1 { font-size: 1.5rem; }
        .markdown-content h2 { font-size: 1.3rem; }
        .markdown-content h3 { font-size: 1.1rem; }
        
        .markdown-content p {
            margin-bottom: 1em;
            line-height: 1.6;
        }
        
        .markdown-content ul, 
        .markdown-content ol {
            padding-left: 1.5em;
            margin-bottom: 1em;
        }
        
        .markdown-content blockquote {
            padding: 0.8em 1em;
            border-left: 4px solid #ced4da;
            background-color: #f8f9fa;
            margin: 0 0 1em;
            color: #495057;
        }
        
        .markdown-content code {
            background-color: #e9ecef;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 85%; /* 稍微小一点 */
            color: #d6336c; /* 粉色代码 */
        }
        
        .markdown-content pre {
            background-color: #f8f9fa;
            padding: 1em;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 0.85rem;
            border: 1px solid #e9ecef;
        }
        .markdown-content pre code {
             background-color: transparent;
             padding: 0;
             border-radius: 0;
             color: inherit;
             font-size: inherit;
        }
        
        .markdown-content img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            margin: 0.5em 0;
        }
        
        .search-result-info {
            font-size: 0.8rem;
            color: #6c757d;
            margin-bottom: 8px;
            font-style: italic;
        }
        
        /* 美化文件上传区域 */
        .file-upload-container {
            border: 1px solid #dee2e6; /* 改为实线边框 */
            border-radius: 0.3rem;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            margin-bottom: 12px;
            background-color: #f8f9fa;
            transition: all 0.2s ease-in-out;
        }
        
        .file-upload-container:hover,
        .file-upload-container.drag-over {
            border-color: #007bff;
            background-color: #e7f5ff;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.2);
        }
        
        .file-upload-label {
            margin-bottom: 8px;
            font-size: 0.85rem;
            color: #6c757d; /* 更深的灰色 */
        }
        
        /* 修复文件输入框问题 */
        .file-input-wrapper {
            position: relative;
            display: inline-block;
        }
        
        .file-select-btn {
            padding: 5px 10px; /* 再小一点 */
            font-size: 0.85rem;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: background-color 0.2s ease-out, transform 0.1s ease-out, box-shadow 0.2s ease-out;
        }
        
        .file-select-btn:hover {
            background-color: #0056b3;
        }
        
        .file-select-btn:active {
            background-color: #004085;
            transform: scale(0.97); /* 调整缩放程度 */
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.2); /* 添加内阴影效果 */
        }
        
        .file-input-wrapper input[type="file"] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-name-display {
            margin-top: 10px;
            font-size: 0.85rem;
            color: #0056b3;
            word-break: break-all;
            padding: 6px 10px;
            background-color: #e7f5ff;
            border-radius: 0.25rem;
            display: flex;
            align-items: center;
            border: 1px solid #b8daff;
            justify-content: space-between;
        }
        
        #current-file-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-right: 10px;
        }
        
        .clear-file-btn {
            background-color: transparent;
            border: none;
            color: #007bff;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 1rem; /* 增大叉号 */
            line-height: 1;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.2s;
            opacity: 0.7;
        }
        
        .clear-file-btn:hover {
            background-color: rgba(0, 123, 255, 0.1);
            opacity: 1;
            color: #0056b3;
        }
        
        /* 多文件管理样式 */
        .files-list {
            margin-top: 10px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }
        
        .files-list-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* File List Styles (Replaces Tabs) */
        .file-list-container {
            margin-top: 10px;
            overflow-y: auto; /* Vertical scrolling */
            flex-grow: 1; /* Allow list to take available space in top section */
            min-height: 50px; /* Ensure it has some minimum height */
            border: 1px solid #e9ecef;
            border-radius: 0.25rem;
            background-color: #ffffff;
        }

        .file-list-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 10px;
            border-bottom: 1px solid #f1f3f5; /* Lighter separator */
            font-size: 0.8rem;
            cursor: pointer;
            transition: background-color 0.15s ease;
            white-space: nowrap;
            overflow: hidden;
        }
        
        .file-list-item:last-child {
             border-bottom: none;
        }

        .file-list-item:hover {
            background-color: #f8f9fa;
        }

        .file-list-item.active {
            background-color: #e7f5ff;
            color: #0056b3;
            font-weight: 500;
        }

        .file-list-item-name {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-right: 8px;
        }

        .file-list-item-close-btn {
            padding: 0 4px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 1.1em;
            line-height: 1;
            color: #adb5bd;
            opacity: 0.7;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .file-list-item:hover .file-list-item-close-btn {
             opacity: 1;
             color: #dc3545;
        }
        
        .file-list-item.active .file-list-item-close-btn {
             color: #007bff;
             opacity: 0.9;
        }
        
        .file-list-item.active:hover .file-list-item-close-btn {
              color: #dc3545;
        }

        .sidebar-top {
            flex-shrink: 0; 
            padding-bottom: 10px; 
            overflow: hidden; /* 改为hidden，让内部元素自己处理滚动 */
            min-height: 100px; 
            position: relative; 
        }
        
        #horizontal-resizer {
            height: 4px; /* 减小高度 */
            background-color: transparent; /* 默认透明 */
            cursor: ns-resize;
            flex-shrink: 0;
            border-top: 1px solid #e9ecef; /* 使用更浅的颜色 */
            border-bottom: 1px solid #e9ecef;
            transition: background-color 0.2s;
            position: relative; /* 用于伪元素 */
        }
        
        #horizontal-resizer:hover {
             background-color: rgba(0, 123, 255, 0.1); /* 悬停时显示浅蓝色 */
        }
        
        /* 添加一个细微的指示线 */
        #horizontal-resizer::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 30%;
            right: 30%;
            height: 1px;
            background-color: #ced4da;
            transform: translateY(-50%);
        }

        .file-upload-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .file-upload-header h2 {
            font-size: 1rem; 
            margin: 0;
            color: #495057;
            flex-grow: 1; /* 占据多余空间 */
        }

        .file-input-wrapper { 
            /* 保持不变，确保按钮和input重叠 */
            position: relative;
            display: inline-block;
        }
        
        .file-select-btn {
            padding: 4px 8px; /* 再小一点 */
            font-size: 0.8rem;
            /* 其他样式保持 */
             background-color: #007bff;
             color: white;
             border: none;
             border-radius: 0.25rem;
             cursor: pointer;
             transition: background-color 0.2s ease-out, transform 0.1s ease-out, box-shadow 0.2s ease-out;
        }
        
        .file-input-wrapper input[type="file"].drag-over {
             /* 可以给input本身加拖放状态提示，但不一定需要 */
             outline: 2px dashed #007bff;
        }

        /* 文件上传区域 - 主要用于拖拽 - 移除 */
        /* .file-upload-container { ... } */
        /* .file-upload-label { ... } */

        /* Sticky Header for User Question */
        .sticky-question-header {
            position: sticky;
            top: -1px; /* 稍微向上移一点，避免与顶部重叠 */
            background-color: rgba(255, 255, 255, 0.95); /* 带透明度的白色背景 */
            padding: 8px 15px;
            border-bottom: 1px solid #e9ecef;
            margin: -15px -20px 15px -20px; /* 调整负边距以填充容器 */
            z-index: 50;
            font-size: 0.85rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            backdrop-filter: blur(5px); /* 毛玻璃效果 */
        }
        
        .sticky-header-label {
             font-weight: 500;
             color: #6c757d;
             margin-right: 8px;
        }
        
        .sticky-header-text {
             color: #343a40;
        }

@media (max-width: 768px) {
    body {
        flex-direction: column;
        /* Keep height 100vh for app-like feel, sub-elements will scroll */
    }

    .sidebar {
        width: 100%;
        max-width: none;
        height: 40vh; /* Sidebar takes 40% of viewport height */
        min-height: 200px; /* Reduced min-height for smaller screens */
        border-right: none;
        border-bottom: 1px solid #dee2e6;
        flex-shrink: 0;
        display: flex; /* Ensures it's a flex container for its children */
        flex-direction: column; /* Stack children vertically */
        overflow: hidden; /* IMPORTANT: Prevents content from spilling out of the 40vh sidebar */
    }

    .sidebar-top {
        display: flex;
        flex-direction: column;
        overflow: hidden;
        height: auto !important; /* Base height for header */
        flex-grow: 0; /* Does not grow by default */
        flex-shrink: 0;
    }

    .sidebar-top.mobile-section-expanded {
        flex-grow: 1 !important;
        /* height: 100% !important; /* REMOVED - Rely on flex-grow */
    }

    .sidebar-top .file-list-container {
        display: none; /* Hidden by default */
    }

    .sidebar-top.mobile-section-expanded .file-list-container {
        display: flex; /* Show and allow flex properties */
        flex-direction: column; /* Stack its children (if any) or manage its own layout */
        flex-grow: 1; /* Takes available space in .sidebar-top */
        /* min-height: 30px; from before, can be kept or adjusted */
    }

    .file-upload-header h2 {
        font-size: 0.9rem;
        margin-bottom: 5px;
        cursor: pointer; /* Indicate clickable */
    }

    #horizontal-resizer {
        display: none !important; /* Hide resizer on mobile */
    }

    .outline { /* This is #sidebar-bottom */
        display: flex;
        flex-direction: column;
        overflow: hidden;
        height: auto !important; /* Base height for header */
        flex-grow: 0; /* Does not grow by default */
        flex-shrink: 0;
    }

    .outline.mobile-section-expanded {
        flex-grow: 1 !important;
        /* height: 100% !important; /* REMOVED - Rely on flex-grow */
    }

    .outline .outline-options,
    .outline .search-box,
    .outline #outline-content {
        display: none; /* Hidden by default */
    }

    .outline.mobile-section-expanded .outline-options,
    .outline.mobile-section-expanded .search-box {
        display: block; /* Or appropriate display type */
    }

    .outline.mobile-section-expanded #outline-content {
        display: flex; /* Show and allow flex properties */
        flex-direction: column;
        flex-grow: 1; /* Takes available space in .outline */
        /* min-height: 30px; from before, can be kept or adjusted */
    }

    .outline h3 {
        font-size: 0.85rem;
        margin-bottom: 3px;
        padding-bottom: 2px;
        cursor: pointer; /* Indicate clickable */
    }

    /* Ensure the main sidebar can contain a single full-height expanded section */
    .sidebar {
        /* ... existing styles like height: 40vh, display: flex, flex-direction: column ... */
        /* Ensure that if one child grows, the other shrinks to its header effectively */
    }

    .main-content {
        width: 100%;
        flex-grow: 1; /* Main content takes remaining vertical space */
        padding: 10px;
    }

    .message {
        max-width: 95%;
        padding: 0.5rem 0.8rem;
    }

    .user-message {
        padding: 0.4rem 0.8rem;
    }

    .file-upload-header {
        flex-direction: column; 
        align-items: flex-start; 
        padding-bottom: 5px; /* Add some space if title wraps */
    }
    .file-upload-header h2 {
        margin-bottom: 8px; 
        font-size: 1rem; 
    }
    .file-input-wrapper {
        align-self: flex-start; /* Align button to the start */
    }
    
    .file-select-btn {
        padding: 6px 10px; /* Adjust padding */
        font-size: 0.85rem;
    }

    .search-input {
        padding: 7px 10px;
        font-size: 0.85rem;
    }

    .outline-item {
        padding: 6px 8px;
        font-size: 0.8rem;
    }
    .outline-options {
        font-size: 0.7rem;
        gap: 8px;
    }
    .outline-options label {
        gap: 2px;
    }
    .outline-options input[type="checkbox"] {
        width: 14px;
        height: 14px;
    }

    .sticky-question-header {
        padding: 6px 10px;
        font-size: 0.75rem;
        margin-left: -10px; 
        margin-right: -10px;
        top: 0;
    }

    /* Improve touch targets for buttons */
    .clear-file-btn {
        padding: 6px 8px;
        font-size: 1.1rem; 
    }
    .file-list-item-close-btn {
        padding: 4px 6px;
        font-size: 1.2em; 
    }
    .file-list-item {
        padding: 7px 10px;
        font-size: 0.85rem;
    }
    
    #no-file h2 {
        font-size: 1.2rem;
    }
    #no-file p {
        font-size: 0.9rem;
    }
}
    </style>
</head>
<body>
    <div class="sidebar" id="sidebar">
        <div id="sidebar-resizer"></div> 
        <div class="sidebar-top" id="sidebar-top">
            <div class="file-upload-header">
                <h2>AI Studio 对话查看器</h2>
                <div class="file-input-wrapper">
                    <button class="file-select-btn" title="选择或拖拽文件到此区域">打开文件</button>
                    <input type="file" id="file-input" multiple>
                </div>
            </div>
            
            <div class="file-list-container" id="file-list-container">
                 <!-- File list items will be added here by JS -->
            </div>
        </div>

        <div id="horizontal-resizer"></div>

        <div class="outline" id="sidebar-bottom">
            <h3>对话提纲</h3>
            <div class="outline-options">
                <label title="提纲高亮跟随视口中第一个可见的用户问题">
                    <input type="checkbox" id="outline-follow-viewport" checked>
                    跟随视口
                </label>
            </div>
            <div class="search-box">
                <input type="text" class="search-input" id="search-input" placeholder="搜索提纲...">
                <div class="search-result-info" id="search-result-info"></div>
            </div>
            <div id="outline-content"></div>
        </div>
    </div>
    
    <div class="main-content" id="conversation">
        <div class="sticky-question-header" id="sticky-question-header" style="display: none;">
            <span class="sticky-header-label">当前回复对应问题:</span>
            <span class="sticky-header-text" id="sticky-question-text"></span>
        </div>
        <div id="no-file">
            <h2>请选择一个文件</h2>
            <p>在左侧上传对话文件以查看内容</p>
        </div>
    </div>

    <script>
        // 配置marked选项
        marked.setOptions({
            breaks: true, 
            gfm: true,    
            sanitize: false 
        });
        
        // 本地存储键名
        const STORAGE_KEY = 'ai_dialog_viewer_last_file';
        
        // DOM元素引用
        const fileInput = document.getElementById('file-input');
        const sidebar = document.getElementById('sidebar');
        const resizer = document.getElementById('sidebar-resizer');
        const fileListContainer = document.getElementById('file-list-container');
        const sidebarTop = document.getElementById('sidebar-top');
        const sidebarBottom = document.getElementById('sidebar-bottom');
        const horizontalResizer = document.getElementById('horizontal-resizer');
        const conversationContainer = document.getElementById('conversation');
        const stickyHeader = document.getElementById('sticky-question-header');
        const stickyHeaderText = document.getElementById('sticky-question-text');
        
        // --- LocalStorage Keys ---
        const LS_OPEN_FILES = 'aiViewer_openFiles';
        const LS_ACTIVE_FILE_ID = 'aiViewer_activeFileId';
        const LS_SIDEBAR_WIDTH = 'aiViewer_sidebarWidth';
        const LS_LAYOUT_RATIO = 'aiViewer_layoutRatio'; // 上下布局比例

        // --- Global State ---
        let openFiles = {}; // 存储打开的文件信息 { id: { name: '...', content: '...' } }
        let activeFileId = null; // 当前活动的文件ID
        let userMessages = []; // 存储用户消息元素、文本和索引，提升到全局作用域
        const MAX_OPEN_FILES = 10; // 最多允许打开的文件数量
        
        let intersectionObserver = null;
        let lastVisibleUserQuestion = null;
        
        // --- File Handling Logic ---
        
        // 处理文件选择
        fileInput.addEventListener('change', handleFileSelect);
        
        // 拖放相关事件
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            document.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        // 拖放样式
        ['dragenter', 'dragover'].forEach(eventName => {
            fileInput.addEventListener(eventName, function(e) {
                e.preventDefault();
                e.stopPropagation();
                fileInput.classList.add('drag-over');
            });
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            fileInput.addEventListener(eventName, function(e) {
                e.preventDefault();
                e.stopPropagation();
                fileInput.classList.remove('drag-over');
            });
        });
        
        // 处理拖放文件
        fileInput.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            fileInput.classList.remove('drag-over'); // 移除拖放样式
            
            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                // 处理多个文件
                for (const file of e.dataTransfer.files) {
                    // 不再检查文件类型
                    // if (file.type === 'application/json') {
                         processFile(file);
                    // } else {
                    //    console.warn(`Skipping non-JSON file: ${file.name}`);
                    // }
                }
                // 清空文件输入，防止重复处理
                fileInput.value = ''; 
            }
        });
        
        // 处理文件选择
        function handleFileSelect(event) {
            if (!event.target.files || event.target.files.length === 0) return;

            // 处理多个文件
            for (const file of event.target.files) {
                 processFile(file);
            }
            // 清空文件输入，防止下次选择相同文件时不触发change事件
            event.target.value = ''; 
        }
        
        // 处理文件的共用函数
        function processFile(file) {
            // 清除旧内容，显示加载中状态
            const conversationElem = document.getElementById('conversation');
            conversationElem.innerHTML = '<div style="text-align: center; margin-top: 50px;">加载中...</div>';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    const fileName = file.name;
                    const fileId = generateUniqueId(fileName, content); // 使用内容和文件名生成ID

                    try {
                        // 尝试解析为JSON
                        const json = JSON.parse(content);
                        
                        // 验证JSON格式是否符合预期
                        if (!json.chunkedPrompt || !json.chunkedPrompt.chunks || !Array.isArray(json.chunkedPrompt.chunks)) {
                            throw new Error("JSON格式不符合对话格式要求");
                        }
                        
                        // 打开或切换到标签页
                        if (!openFileInList(fileId, fileName, content)) {
                             // 如果无法打开（例如达到上限），则重置加载状态
                             clearFileState(true);
                        }
                       
                    } catch (jsonError) {
                        console.error("解析JSON失败:", jsonError, "File:", fileName);
                        alert(`文件 '${fileName}' 不是有效的对话格式。请上传包含正确对话内容的JSON文件。`);
                        // clearFileState(true); // 不再清除状态，保留当前有效内容
                    }
                } catch (error) {
                    alert(`读取文件 '${fileName}' 失败：${error.message}`);
                    // clearFileState(true); // 不再清除状态
                }
            };
            reader.readAsText(file);
        }
        
        // 生成唯一ID (稍微改进，使其更稳定)
        function generateUniqueId(name, content) {
            // 简单的基于名称和内容长度的哈希，实际应用可能需要更可靠方法
            const hash = name + '_' + content.length;
            return hash.split('').reduce((a,b)=>{a=((a<<5)-a)+b.charCodeAt(0);return a&a},0).toString(16);
        }
        
        // 清除文件状态，但可选是否保留文件名显示
        function clearFileState(clearFileName = true) {
            // 清除对话内容
            const conversationElem = document.getElementById('conversation');
            const outlineContentElem = document.getElementById('outline-content');
            
            // 添加"请选择文件"提示
            if (conversationElem) {
                conversationElem.innerHTML = `
                    <div id="no-file">
                        <h2>请选择一个文件</h2>
                        <p>在左侧上传对话文件以查看内容</p>
                    </div>
                `;
            }
            
            // 清空提纲内容
            if (outlineContentElem) {
                outlineContentElem.innerHTML = '';
            }
        }

        // --- 初始化和URL加载逻辑 ---
        document.addEventListener('DOMContentLoaded', function() {
            // 初始化时加载状态
            loadStateFromLocalStorage();

            // 如果加载后没有任何活动文件，则显示初始提示
            if (!activeFileId) {
                clearFileState(true);
            }

            // 处理URL文件加载 (这部分逻辑在loadState之后执行，如果URL提供了文件，会覆盖之前的状态)
            const urlParams = new URLSearchParams(window.location.search);
            const fileUrl = urlParams.get('file');
            
            if (fileUrl) {
                const conversationElem = document.getElementById('conversation');
                if (conversationElem) {
                    conversationElem.innerHTML = '<div style="text-align: center; margin-top: 50px;">正在从URL加载文件...</div>';
                }
                
                fetch(fileUrl)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('网络请求失败: ' + response.status);
                        }
                        return response.text();
                    })
                    .then(text => {
                        try {
                            const json = JSON.parse(text);
                            if (!json.chunkedPrompt || !json.chunkedPrompt.chunks || !Array.isArray(json.chunkedPrompt.chunks)) {
                                throw new Error("JSON格式不符合对话格式要求");
                            }
                            
                            const fileName = '从URL加载的文件';
                            const fileId = generateUniqueId(fileName, text);
                            
                            // 打开或切换到标签页
                            openFileInList(fileId, fileName, text);
                            
                        } catch (error) {
                            console.error('解析文件失败:', error);
                            alert('无法解析URL提供的文件，请确保是有效的对话格式。');
                            clearFileState(true);
                        }
                    })
                    .catch(error => {
                        console.error('加载文件失败:', error);
                        alert('从URL加载文件失败: ' + error.message);
                        clearFileState(true);
                    });
            }
        });
        
        // 清除内存中的状态，但不影响文件显示和本地存储
        function clearInMemoryState() {
            const conversationElem = document.getElementById('conversation');
            const outlineContentElem = document.getElementById('outline-content');
            
            // 清空DOM内容以释放内存
            conversationElem.innerHTML = '';
            outlineContentElem.innerHTML = '';
        }
        
        // --- Sidebar Resizing Logic ---
        let isResizing = false;
        let startX;
        let startWidth;
        
        resizer.addEventListener('mousedown', function(e) {
            isResizing = true;
            startX = e.clientX;
            startWidth = sidebar.offsetWidth;
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            document.body.style.cursor = 'col-resize'; // 设置全局光标
            document.body.style.userSelect = 'none'; // 防止拖动时选中文本
        });
        
        function handleMouseMove(e) {
            if (!isResizing) return;
            const newWidth = startWidth + e.clientX - startX;
            const minWidth = parseInt(getComputedStyle(sidebar).minWidth);
            const maxWidth = parseInt(getComputedStyle(sidebar).maxWidth);
            
            if (newWidth >= minWidth && newWidth <= maxWidth) {
                sidebar.style.width = newWidth + 'px';
            }
        }
        
        function handleMouseUp() {
            if (isResizing) {
                isResizing = false;
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
                document.body.style.cursor = ''; // 恢复默认光标
                document.body.style.userSelect = ''; // 恢复文本选择
            }
        }
        // --- End Sidebar Resizing Logic ---
        
        // --- Horizontal Resizing Logic ---
        let isResizingHorizontal = false;
        let startYHorizontal;
        let startHeightTop;

        horizontalResizer.addEventListener('mousedown', function(e) {
            isResizingHorizontal = true;
            startYHorizontal = e.clientY;
            startHeightTop = sidebarTop.offsetHeight;
            document.addEventListener('mousemove', handleMouseMoveHorizontal);
            document.addEventListener('mouseup', handleMouseUpHorizontal);
            document.body.style.cursor = 'ns-resize';
            document.body.style.userSelect = 'none';
        });

        function handleMouseMoveHorizontal(e) {
            if (!isResizingHorizontal) return;
            const deltaY = e.clientY - startYHorizontal;
            let newHeightTop = startHeightTop + deltaY;
            
            // 添加最小高度限制，防止区域过小
            const minHeight = 50; // 例如，顶部区域最小高度50px
            const sidebarTotalHeight = sidebar.offsetHeight;
            const resizerHeight = horizontalResizer.offsetHeight;
            
            if (newHeightTop < minHeight) {
                newHeightTop = minHeight;
            }
            if (sidebarTotalHeight - newHeightTop - resizerHeight < minHeight) {
                // 保证底部区域也有最小高度
                newHeightTop = sidebarTotalHeight - minHeight - resizerHeight;
            }

            sidebarTop.style.height = newHeightTop + 'px';
            // 底部区域高度自动调整 (通过flex-grow: 1)
            // sidebarBottom.style.height = (sidebarTotalHeight - newHeightTop - resizerHeight) + 'px'; // 或者手动设置
        }

        function handleMouseUpHorizontal() {
            if (isResizingHorizontal) {
                isResizingHorizontal = false;
                document.removeEventListener('mousemove', handleMouseMoveHorizontal);
                document.removeEventListener('mouseup', handleMouseUpHorizontal);
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                saveStateToLocalStorage(); // 保存布局状态
            }
        }
        // --- End Horizontal Resizing Logic ---
        
        // --- Tab Management Logic ---
        
        // 渲染文件列表 (替代 renderTabs)
        function renderFileList() {
            fileListContainer.innerHTML = '';
            Object.keys(openFiles).forEach(fileId => {
                const file = openFiles[fileId];
                const listItem = createFileListItemElement(fileId, file.name);
                fileListContainer.appendChild(listItem);
            });
        }

        // 创建单个文件列表项元素 (替代 createTabElement)
        function createFileListItemElement(fileId, fileName) {
            const listItem = document.createElement('div');
            listItem.className = `file-list-item ${fileId === activeFileId ? 'active' : ''}`;
            listItem.setAttribute('data-file-id', fileId);

            const nameSpan = document.createElement('span');
            nameSpan.className = 'file-list-item-name';
            nameSpan.textContent = fileName;
            nameSpan.title = fileName; 
            listItem.appendChild(nameSpan);

            const closeBtn = document.createElement('button');
            closeBtn.className = 'file-list-item-close-btn';
            closeBtn.innerHTML = '&times;'; 
            closeBtn.title = '关闭文件';
            closeBtn.onclick = function(e) {
                e.stopPropagation(); 
                closeFile(fileId);
            };
            listItem.appendChild(closeBtn);

            // 点击列表项切换文件
            listItem.onclick = function() {
                switchToFile(fileId);
            };

            return listItem;
        }
        
        // 切换到指定文件
        function switchToFile(fileId) {
            if (!openFiles[fileId]) {
                console.warn(`Attempted to switch to non-existent file ID: ${fileId}`);
                const remainingFileIds = Object.keys(openFiles);
                 if (remainingFileIds.length > 0) {
                     switchToFile(remainingFileIds[0]);
                 } else {
                     clearFileState(true);
                 }
                return;
            }
            if (fileId === activeFileId) return; 

            activeFileId = fileId;
            const file = openFiles[fileId];
            
            renderFileList(); // 更新高亮列表项
            saveStateToLocalStorage();
            
            try {
                const json = JSON.parse(file.content);
                renderConversation(json);
            } catch (e) {
                console.error("解析文件内容失败:", fileId, e);
                alert(`无法解析文件 ${file.name} 的内容。`);
            }
        }

        // 关闭指定文件 (替代 closeFileTab)
        function closeFile(fileId, shouldSwitch = true) { 
            if (!openFiles[fileId]) return;

            const wasActive = (fileId === activeFileId);
            delete openFiles[fileId]; 

            try {
                const fileKey = 'ai_dialog_file_' + fileId;
                localStorage.removeItem(fileKey);
            } catch (e) {
                console.error("Failed to remove file content from localStorage:", e);
            }

            if (wasActive && shouldSwitch) {
                activeFileId = null;
                const remainingFileIds = Object.keys(openFiles);
                if (remainingFileIds.length > 0) {
                    switchToFile(remainingFileIds[remainingFileIds.length - 1]);
                } else {
                    clearFileState(true);
                }
            } else if (wasActive && !shouldSwitch) {
                 activeFileId = null; 
            }
            
            renderFileList(); // 更新文件列表
            saveStateToLocalStorage();
        }

        // 打开文件并添加到列表 (替代 openFileInTab)
        function openFileInList(fileId, fileName, fileContent) {
            const currentFileCount = Object.keys(openFiles).length;
            if (currentFileCount >= MAX_OPEN_FILES && !openFiles[fileId]) {
                if (currentFileCount >= MAX_OPEN_FILES) {
                     const firstFileId = Object.keys(openFiles)[0];
                     console.log(`Max files reached. Closing file: ${openFiles[firstFileId]?.name}`);
                     closeFile(firstFileId, false); // 关闭但不立即切换
                }
                if (Object.keys(openFiles).length >= MAX_OPEN_FILES && !openFiles[fileId]) {
                    alert(`最多只能同时打开 ${MAX_OPEN_FILES} 个文件。请先关闭一些。`);
                    return false;
                }
            }
            
            openFiles[fileId] = { name: fileName, content: fileContent };
            
            try {
                const fileKey = 'ai_dialog_file_' + fileId;
                localStorage.setItem(fileKey, fileContent);
            } catch (e) {
                 console.error("Failed to save file content to localStorage:", e);
                 tryCleanupStorage(); 
                 alert('无法保存文件内容，本地存储空间可能已满。');
                 delete openFiles[fileId]; 
                 return false;
            }
            
            switchToFile(fileId); 
            saveStateToLocalStorage(); 
            return true;
        }

        // --- End Tab Management Logic ---

        // --- Rendering Logic ---
        function renderConversation(json) {
            const conversationElem = document.getElementById('conversation');
            const outlineContentElem = document.getElementById('outline-content');

            // 断开旧的 observer
            if (intersectionObserver) {
                intersectionObserver.disconnect();
            }
            lastVisibleUserQuestion = null; // 重置状态
            stickyHeader.style.display = 'none'; // 隐藏悬浮头

            // 清空当前内容，确保 #no-file 提示被移除（如果存在）
            conversationElem.innerHTML = '';
            outlineContentElem.innerHTML = '';
            userMessages = []; // 清空全局的 userMessages
            
            // 验证数据结构
            if (!json || !json.chunkedPrompt || !json.chunkedPrompt.chunks || !Array.isArray(json.chunkedPrompt.chunks)) {
                console.error("Invalid conversation data structure provided to renderConversation");
                conversationElem.innerHTML = '<div style="color: red; margin-top: 20px;">错误：对话数据格式无效。</div>';
                return;
            }
            
            const chunks = json.chunkedPrompt.chunks;
            let userQuestionIndex = 0;
            chunks.forEach((chunk) => {
                if (chunk.role === 'user' && chunk.isThought !== true) {
                    const questionId = `question-${userQuestionIndex}`;
                    const outlineItem = document.createElement('div');
                    outlineItem.className = 'outline-item';
                    outlineItem.setAttribute('data-content', chunk.text.toLowerCase());
                    
                    const fullText = chunk.text;
                    const questionText = fullText.length > 30 ? fullText.substring(0, 30) + '...' : fullText; 
                    
                    outlineItem.textContent = `${userQuestionIndex + 1}: ${questionText}`;
                    outlineItem.title = fullText; 
                    outlineItem.onclick = function() {
                        const targetElement = document.getElementById(questionId);
                        if (targetElement) {
                            targetElement.scrollIntoView({ behavior: 'smooth' });
                        }
                    };
                    outlineContentElem.appendChild(outlineItem);
                    // userMessages.push({ element: null, text: fullText, index: userQuestionIndex }); // 先存文本 - 此处不再需要，统一在渲染时处理
                    userQuestionIndex++;
                }
            });

            // 渲染对话消息
            let currentUserMessageIndex = -1;
            chunks.forEach((chunk) => {
                if (chunk.isThought === true) return; 

                const isUser = chunk.role === 'user';
                const messageElem = document.createElement('div');
                messageElem.className = `message ${isUser ? 'user-message' : 'model-message'}`;

                if (isUser) {
                    currentUserMessageIndex++;
                    messageElem.id = `question-${currentUserMessageIndex}`;
                    messageElem.setAttribute('data-question-index', currentUserMessageIndex);
                    // 在渲染时填充 userMessages 数组
                    if (userMessages.length <= currentUserMessageIndex) { // 确保数组有足够空间
                        userMessages.push({ element: messageElem, text: chunk.text, index: currentUserMessageIndex });
                    } else {
                        userMessages[currentUserMessageIndex] = { element: messageElem, text: chunk.text, index: currentUserMessageIndex };
                    }
                } else {
                    // 模型消息关联到上一个用户问题的索引
                    if (currentUserMessageIndex >= 0) {
                         messageElem.setAttribute('data-related-question-index', currentUserMessageIndex);
                    }
                }

                const headerElem = document.createElement('div');
                headerElem.className = 'message-header';
                headerElem.textContent = isUser ? '用户' : '模型回复';
                messageElem.appendChild(headerElem);

                const contentElem = document.createElement('div');
                contentElem.className = 'message-content markdown-content';
                try {
                     contentElem.innerHTML = marked.parse(chunk.text || ''); 
                } catch (e) {
                    console.error("Markdown parsing error:", e);
                    contentElem.textContent = "无法渲染此消息内容。";
                }
                messageElem.appendChild(contentElem);
                
                conversationElem.appendChild(messageElem);
            });

            // 初始化 IntersectionObserver
            setupIntersectionObserver(conversationContainer, userMessages);
        }

        // 设置 IntersectionObserver 监控消息可见性
        function setupIntersectionObserver(container, userMessages) {
            const options = {
                root: container, // 相对于对话容器
                rootMargin: '-50px 0px -50% 0px', // 顶部偏移50px，底部看一半就触发
                threshold: 0
            };

            intersectionObserver = new IntersectionObserver((entries) => {
                let topMostModelMessageIndex = -1;
                let topMostUserMessageIndex = -1;

                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const modelIndex = entry.target.getAttribute('data-related-question-index');
                        const userIndex = entry.target.getAttribute('data-question-index');
                        
                        if (modelIndex !== null) {
                            const index = parseInt(modelIndex, 10);
                            if (topMostModelMessageIndex === -1 || index < topMostModelMessageIndex) {
                                topMostModelMessageIndex = index;
                            }
                        } else if (userIndex !== null) {
                            const index = parseInt(userIndex, 10);
                             if (topMostUserMessageIndex === -1 || index < topMostUserMessageIndex) {
                                topMostUserMessageIndex = index;
                            }
                            // 如果用户消息可见，更新最后可见用户问题
                            lastVisibleUserQuestion = userMessages[index];
                        }
                    }
                });

                // 更新悬浮头
                if (topMostModelMessageIndex !== -1 && topMostModelMessageIndex >= topMostUserMessageIndex) {
                    // 如果顶部是模型消息，或者模型消息比用户消息更靠上
                    const relatedQuestion = userMessages[topMostModelMessageIndex];
                    if (relatedQuestion) {
                        stickyHeaderText.textContent = relatedQuestion.text.length > 80 ? relatedQuestion.text.substring(0, 80) + '...' : relatedQuestion.text;
                        stickyHeader.style.display = 'block';
                        lastVisibleUserQuestion = relatedQuestion; // 更新最后关联的用户问题
                    }
                } else if (topMostUserMessageIndex !== -1) {
                     // 如果顶部是用户消息，则隐藏悬浮头
                     stickyHeader.style.display = 'none';
                } else {
                    // 如果滚到很远，没有监控到任何消息，则尝试使用最后一次看到的用户消息
                    if(lastVisibleUserQuestion) {
                         stickyHeaderText.textContent = lastVisibleUserQuestion.text.length > 80 ? lastVisibleUserQuestion.text.substring(0, 80) + '...' : lastVisibleUserQuestion.text;
                         stickyHeader.style.display = 'block';
                    } else {
                         stickyHeader.style.display = 'none';
                    }
                }
                
                // 更新提纲高亮 (后续步骤添加)
                updateOutlineHighlight(); 

            }, options);

            // 观察所有消息元素
            container.querySelectorAll('.message').forEach(el => {
                intersectionObserver.observe(el);
            });
        }

        // --- Search Functionality ---
        document.getElementById('search-input').addEventListener('input', function(event) {
            const searchTerm = event.target.value.toLowerCase();
            const outlineItems = document.querySelectorAll('#outline-content .outline-item');
            const searchResultInfo = document.getElementById('search-result-info');
            let visibleCount = 0;

            outlineItems.forEach(item => {
                const content = item.getAttribute('data-content') || '';
                if (content.includes(searchTerm)) {
                    item.classList.remove('hidden');
                    visibleCount++;
                } else {
                    item.classList.add('hidden');
                }
            });

            if (searchTerm) {
                searchResultInfo.textContent = `找到 ${visibleCount} 个结果。`;
            } else {
                searchResultInfo.textContent = '';
            }
        });

        // --- Outline Highlight Logic ---
        function updateOutlineHighlight() {
            const outlineItems = document.querySelectorAll('#outline-content .outline-item');
            outlineItems.forEach(item => item.classList.remove('highlight'));

            const followViewportCheckbox = document.getElementById('outline-follow-viewport');
            let questionToHighlight = null;

            if (followViewportCheckbox && followViewportCheckbox.checked && lastVisibleUserQuestion) {
                questionToHighlight = lastVisibleUserQuestion;
            } 

            if (questionToHighlight) {
                const targetOutlineItem = document.querySelector(`#outline-content .outline-item:nth-child(${questionToHighlight.index + 1})`);
                if (targetOutlineItem) {
                    targetOutlineItem.classList.add('highlight');
                    // 滚动提纲到高亮项
                    targetOutlineItem.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                }
            }
        }

        // 为提纲同步选项添加事件监听
        const followViewportCheckbox = document.getElementById('outline-follow-viewport');
        if (followViewportCheckbox) {
            followViewportCheckbox.addEventListener('change', updateOutlineHighlight);
        }
        // --- End Outline Highlight Logic ---

        // 保存状态到LocalStorage
        function saveStateToLocalStorage() {
            try {
                // 只保存文件的元数据（ID和名称），不保存内容
                const filesMetadata = {};
                Object.keys(openFiles).forEach(id => {
                    filesMetadata[id] = { name: openFiles[id].name };
                });
                localStorage.setItem(LS_OPEN_FILES, JSON.stringify(filesMetadata));
                localStorage.setItem(LS_ACTIVE_FILE_ID, activeFileId || '');
                localStorage.setItem(LS_SIDEBAR_WIDTH, sidebar.style.width || '');
                // 保存上下布局比例
                const topHeight = sidebarTop.offsetHeight;
                const totalHeight = sidebar.offsetHeight - horizontalResizer.offsetHeight;
                if (totalHeight > 0) {
                    const ratio = topHeight / totalHeight;
                    localStorage.setItem(LS_LAYOUT_RATIO, ratio.toFixed(2));
                }
            } catch (e) {
                console.error("Failed to save state to localStorage:", e);
            }
        }

        // 从LocalStorage加载状态
        function loadStateFromLocalStorage() {
            try {
                const savedFilesMeta = JSON.parse(localStorage.getItem(LS_OPEN_FILES) || '{}');
                const savedActiveId = localStorage.getItem(LS_ACTIVE_FILE_ID);
                const savedSidebarWidth = localStorage.getItem(LS_SIDEBAR_WIDTH);
                const savedLayoutRatio = parseFloat(localStorage.getItem(LS_LAYOUT_RATIO));

                if (savedSidebarWidth) {
                     sidebar.style.width = savedSidebarWidth;
                }
                
                // 恢复布局比例 - 仅限非移动端
                if (!isMobile()) { 
                    if (!isNaN(savedLayoutRatio) && savedLayoutRatio > 0 && savedLayoutRatio < 1) {
                        const totalHeight = sidebar.offsetHeight - (document.getElementById('horizontal-resizer').offsetHeight || 0);
                        if (totalHeight > 0) {
                             let topHeight = totalHeight * savedLayoutRatio;
                             const minHeight = 50; // 与拖动逻辑中的最小值保持一致
                             if (topHeight < minHeight) topHeight = minHeight;
                             if (totalHeight - topHeight < minHeight) topHeight = totalHeight - minHeight;
                             sidebarTop.style.height = topHeight + 'px';
                        }
                    }
                } else {
                    // 在移动端，确保清除任何可能由桌面端保存的内联高度
                    sidebarTop.style.height = ''; 
                    sidebarBottom.style.height = ''; // sidebarBottom is the .outline div
                    setupMobileSidebarToggle(); // 初始化移动端切换逻辑
                }

                // 重新打开文件（需要从单独存储中加载内容）
                Object.keys(savedFilesMeta).forEach(fileId => {
                    const fileKey = 'ai_dialog_file_' + fileId;
                    const fileContent = localStorage.getItem(fileKey);
                    if (fileContent) {
                        openFiles[fileId] = {
                            name: savedFilesMeta[fileId].name,
                            content: fileContent
                        };
                    } else {
                        console.warn(`Content for file ${fileId} not found in localStorage.`);
                    }
                });

                // 渲染标签
                renderFileList();

                // 尝试切换到上次活动的标签
                if (savedActiveId && openFiles[savedActiveId]) {
                    switchToFile(savedActiveId);
                } else if (Object.keys(openFiles).length > 0) {
                    // 如果上次活动的无效，切换到第一个
                    switchToFile(Object.keys(openFiles)[0]);
                } else {
                     clearFileState(true); // 没有任何文件，显示初始状态
                }

            } catch (e) {
                console.error("Failed to load state from localStorage:", e);
                // 加载失败，清理可能损坏的数据
                localStorage.removeItem(LS_OPEN_FILES);
                localStorage.removeItem(LS_ACTIVE_FILE_ID);
                localStorage.removeItem(LS_SIDEBAR_WIDTH);
                localStorage.removeItem(LS_LAYOUT_RATIO);
                clearFileState(true);
            }
        }

        // --- Mobile Specific Logic ---
        function isMobile() {
            return window.innerWidth <= 768;
        }

        function setupMobileSidebarToggle() {
            const fileHeader = sidebarTop.querySelector('.file-upload-header h2');
            const outlineHeader = sidebarBottom.querySelector('.outline h3');

            const sections = [
                { header: fileHeader, section: sidebarTop, name: 'files' },
                { header: outlineHeader, section: sidebarBottom, name: 'outline' }
            ];

            function toggleSections(activeSectionName) {
                sections.forEach(s => {
                    if (s.name === activeSectionName) {
                        s.section.classList.add('mobile-section-expanded');
                    } else {
                        s.section.classList.remove('mobile-section-expanded');
                    }
                });
            }

            sections.forEach(s => {
                if (s.header) { // Ensure header exists
                    s.header.addEventListener('click', () => toggleSections(s.name));
                }
            });

            // Default to files section being expanded on mobile
            toggleSections('files'); 
        }

        // Re-check on resize for toggling mobile/desktop behavior if necessary
        // This is a simple version; more complex scenarios might need to undo/redo event listeners
        let currentIsMobile = isMobile();
        window.addEventListener('resize', () => {
            const newIsMobile = isMobile();
            if (newIsMobile !== currentIsMobile) {
                currentIsMobile = newIsMobile;
                // If transitioning from desktop to mobile, setup toggles
                if (newIsMobile) {
                    sidebarTop.style.height = ''; 
                    sidebarBottom.style.height = '';
                    setupMobileSidebarToggle();
                } else {
                    // If transitioning from mobile to desktop, remove expanded classes and rely on localStorage restore or defaults
                    sidebarTop.classList.remove('mobile-section-expanded');
                    sidebarBottom.classList.remove('mobile-section-expanded');
                    // Potentially re-apply desktop layout ratio if needed, or let loadState handle it on next load
                    // For simplicity, we'll let `loadStateFromLocalStorage` handle it if the user reloads or if it's called again.
                    // Or explicitly call parts of loadStateFromLocalStorage for layout ratio if resize handling becomes more complex.
                    // Removing event listeners from headers might also be needed if they conflict with desktop.
                    // For now, the click listeners on h2/h3 will just add/remove classes that only have effect on mobile due to media query.
                }
            }
        });

    </script>
</body>
</html>
